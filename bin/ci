#!/usr/bin/env ruby
# frozen_string_literal: true

require_relative "../loader"
require "time"
require "optparse"
require "net/http"
require "uri"
require "json"

def main(options)
  project = Project.create_with_id(name: "Test Project")
  project.associate_with_project(project)

  # Tricky way to have project with pre-defined config value
  puts "15151515151515151515151515"
  github_service_project = Project.create_with_id(name: "Github Service Project")
  DB.run "UPDATE project SET id = '#{Config.gh_runner_service_project_id}' WHERE id = '#{github_service_project.id}'"
  github_service_project = Project[Config.gh_runner_service_project_id]
  github_service_project.reload
  github_service_project.associate_with_project(github_service_project)

  puts "23232323232323232323232323"
  hetzner_server_st = Prog::Test::HetznerServer.assemble(vm_host_id: options[:vm_host_id])
  wait_until(hetzner_server_st, "wait")

  vmh = VmHost.first

  puts "29292929292929292929292929"
  image_download_st = vmh.download_boot_image("github-ubuntu-2204")
  wait_until(image_download_st)
  puts "32323232323232323232323232"
  vmh.update(allocation_state: "accepting")
  puts "34343434343434343434343434"
  vmh.reload
  puts "36363636363636363636363636"
  puts "vmh: #{vmh.inspect}"

  sleep(10)
  puts "37373737373737373737373737"
  puts "vmh: #{vmh.inspect}"
  vmh.update(allocation_state: "accepting")
  vmh.reload
  puts "vmh: #{vmh.inspect}"
  puts "38383838383838383838383838"
  GithubInstallation.create_with_id(
    installation_id: Config.gh_installation_id,
    name: "velioglu",
    type: "User",
    project_id: project.id
  )

  # Replace with your details
  repo = "velioglu/github_e2e"
  workflow_id = "test.yml"
  token = Config.gh_pat
  branch = "main" # or the branch you want to trigger the workflow on

  puts "48484848484848484848484848"

  # Construct the API endpoint
  url = URI("https://api.github.com/repos/#{repo}/actions/workflows/#{workflow_id}/dispatches")

  # Prepare the HTTP request
  http = Net::HTTP.new(url.host, url.port)
  http.use_ssl = true
  request = Net::HTTP::Post.new(url)
  request["Accept"] = "application/vnd.github.v3+json"
  request["Authorization"] = "token #{token}"
  request.body = {ref: branch}.to_json

  # Send the request
  response = http.request(request)
  puts "Response: #{response.code} #{response.message}"
  puts response.body if response.code.to_i >= 400

  puts "55555555555555555555555555"

  sleep(300)
  Semaphore.incr(hetzner_server_st.id, "destroy")
  wait_until(hetzner_server_st)
end

def wait_until(st, label = nil)
  while (loaded_st = Strand[st.id]) && loaded_st.label != label
    if loaded_st.label == "failed"
      log(st.reload, "FAILED: #{loaded_st.exitval.fetch("msg")}")
      st.destroy
      exit 1
    end
    log(st.reload, "waiting #{label ? "for #{label}" : "exit"}")
    sleep 10
  end
  log(st, "reached")
end

def log(st, msg)
  resources = case st.prog
  when "Test::HetznerServer"
    "VmHost.#{Strand[st.stack.first["vm_host_id"]]&.label}"
  when "Test::VmGroup"
    st.stack.first["vms"].map { "Vm.#{Strand[_1]&.label}" }.join(", ")
  when "Test::Vm"
    "Vm.#{Strand[st.stack.first["subject_id"]]&.label}"
  else
    "#{st.prog}.#{st.label}"
  end
  $stdout.write "#{Time.now.utc.iso8601} | #{st.id} | #{st.prog}.#{st.label} | #{msg} | #{resources}\n"
end

options = {}
OptionParser.new do |opts|
  opts.on("--vm-host-id VM_HOST_ID", "Use existing vm host") { |v| options[:vm_host_id] = (v.length == 26) ? VmHost.from_ubid(v).id : v }
end.parse!

clover_freeze

$stdout.sync = true

main(options)
